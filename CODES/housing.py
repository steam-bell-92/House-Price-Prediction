# -*- coding: utf-8 -*-
"""Housing

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OOy5S-VOscTQKYflY0PClCVnw1iUwcAM

## ***Exploratory Data Analysis (EDA)***
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install kaleido
# %pip install plotly --upgrade

"""## Importing all libraries for EDA"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
# %matplotlib inline
import plotly.express as px

from google.colab import drive
drive.mount('/content/drive')

"""# Reading dataset"""

df = pd.read_csv('/content/drive/MyDrive/Housing.csv')
df.head()

"""# Basic Things about dataset

Getting shape/size of the datset
"""

print(df.shape)

"""Getting names of columns present in dataset"""

print(df.columns)

"""Checking duplicate rows in datset"""

dupes = df.duplicated().sum()
print(f"Number of dupes in the dataset are : {dupes}")

"""Checking missing values in dataset"""

missing = df.isnull().sum()
print(f"Number of missing values in the dataset are : {missing.sum()}")

"""Getting Datatypes of all columns datatype"""

pd.DataFrame(df).dtypes

"""# Getting more basic description

Statistical description of dataset
"""

df.describe()

"""Summary of the Dataset"""

df.info()

"""Types of furnishing status in dataset"""

furnish_types = list(df['furnishingstatus'].unique())
print(f"Types of furnishing statuses are : {*furnish_types,}")

"""Finding Houses with all appliances"""

appliances_all = df[(df['airconditioning']=='yes') & (df['hotwaterheating']=='yes')]
print(f'Number of houses with all appliances:  {len(appliances_all)}')
appliances_all.head()

"""Finding Houses with no appliances"""

appliances_no = df[(df['airconditioning']=='no') & (df['hotwaterheating']=='no')]
print(f'Number of houses with no appliances:  {len(appliances_no)}')
appliances_no.head()

"""# An KDE (Kernel Density Estimation) Plot for detecting outliners"""

sns.kdeplot(x='area' , y='price', data=df, hue='furnishingstatus', fill=True, thresh=0.005, levels=100)
plt.xlabel('Area')
plt.ylabel('Price')
plt.title('Price Distribution by Furnishing Status')
plt.show()

fig1 = px.density_contour(df, x='area', y='price', color='furnishingstatus', title='Price Distribution by Furnishing Status')
fig1.update_traces(contours_coloring="fill", contours_showlabels = True)
fig1.show()

"""# Plotting a boxplot to check outliners"""

sns.boxplot(x='furnishingstatus', y='area', data=df)
plt.title('Boxplot for price vs area')
plt.show()

fig2 = px.box(df, x='furnishingstatus', y='area', title='Boxplot for price vs area', notched=True, points='all')
fig2.show()

"""# Introduction a new parameter: total_rooms"""

df['total_rooms'] = df['bedrooms'] + df['bathrooms']

""" Calculating Mean of :
*   Price per sq.feet
*   Price per number of rooms

"""

df['price/sq.feet'] = df['price'] / df['area']
df['price/rooms'] = df['price'] / df['total_rooms']
print(f"Mean price per sq.feet : {df['price/sq.feet'].mean()}")
print(f"Mean price per number of rooms : {df['price/rooms'].mean()}")

"""# Removing outliners based on various parameters using IQR (Inter Quantile Range) Method"""

outliners_data = [df['price'], df['area'], df['total_rooms'], df['price/sq.feet'], df['price/rooms']]
for i in  outliners_data:
  Q1 = i.quantile(0.25)
  Q3 = i.quantile(0.75)
  IQR = Q3 - Q1
  lower_bound = Q1 - 1.5 * IQR
  upper_bound= Q3 + 1.5 * IQR
  df_no_out = df[(i >= lower_bound) & (i <= upper_bound)].copy()
df_no_out.index = range(1, len(df_no_out)+1)
df_no_out.head()

"""Calculating number of outliners"""

outliners = len(df) - len(df_no_out)
print(f"Number of outliners are : {outliners}")

"""# Plot of Price per sq.feet with & without outliners


"""

sns.histplot(df['price/sq.feet'] , kde=True, bins=25, label='Data with outliners', alpha=1)
sns.histplot(df_no_out['price/sq.feet'], kde=True, bins=25, label='Data without outliners', alpha = 0.5)
plt.title('Frequencies of Price per Square Feet')
plt.xlabel('Price per Square Feet')
plt.ylabel('Frequency')
plt.legend()
plt.tight_layout()
plt.show()

"""# Predicting House prices using is area as only factor via regplot (Regression Plot)"""

sns.regplot(x='area', y='price', data=df, scatter=False, order=3, label='Data with outliners')
sns.regplot(x='area', y='price', data=df_no_out, scatter=False, order=3, label='Data without outliners')

plt.xlabel('Area')
plt.ylabel('Prices')
plt.title('Prediction of House prices using its Area as only factor')
plt.xlim(df['area'].min(), df['area'].max())
plt.ylim(0, df['price'].max())
plt.legend()
plt.show()

"""# Predicting House prices using areas are for various furnishing status via lmplot (Linear Model Plot)"""

sns.lmplot(data=df, x='area', y='price', hue='furnishingstatus', height=5, scatter=False, order=3, legend=False)
plt.title("Regression Lines for Different Furnishing Statuses")
plt.xlabel("Area (sq ft)")
plt.ylabel("Price")
plt.xlim(df['area'].min(), df['area'].max())
plt.ylim(0, df['price'].max())
plt.legend(loc='best')
plt.show()

"""# Plot of Price per number of rooms with & without outliners"""

sns.histplot(df['price']/df['total_rooms'] , kde=True, bins=25, label='Data with outliners')
sns.histplot(df_no_out['price']/df['total_rooms'] , kde=True, bins=25, label='Data without outliners')
plt.title('Frequncies of Price per Number of Rooms')
plt.xlabel('Price per Number of Rooms')
plt.ylabel('Frequency')
plt.legend(loc='best')
plt.tight_layout()
plt.show()

"""# Introdution a new parameter: has_parking"""

df_no_out['has_parking'] = 'no'
df_no_out.loc[df_no_out['parking'] > 0, 'has_parking'] = 'yes'

df_no_out.head()

"""Going to convert 'str' dtypes to 'int'.

*   mainroad
*   guestroom
*   hotwaterheating
*   prefarea
*   airconditioning

Convention : 'yes' : 1, 'no' : 0, True : 1, False : 0

# Converting 'yes' & 'no' of the datset into '1' & '0' respectively
"""

def convert_str_to_int (col) :
    df_no_out[col] = df_no_out[col].map({'yes':1, 'no':0, True:1, False:0})

for col in ['mainroad', 'guestroom', 'basement', 'hotwaterheating', 'prefarea', 'airconditioning', 'has_parking'] :
  convert_str_to_int(col)
df_no_out.head()

"""# Introducing new parameters: log(prices) & log(area)
for skewed data if found/required
"""

df_no_out['log_prices'] = np.log(df_no_out['price'])
df_no_out['log_area'] = np.log(df_no_out['area'])

"""# Introduction new parameter: luxury_score"""

df_no_out['luxury_score'] = 0.125*(df_no_out['price']/df_no_out['price'].max())
+ 0.175*(df_no_out['area']/df_no_out['area'].max())
+ 0.15*(df_no_out['total_rooms']/df_no_out['total_rooms'].max())
+ 0.07*(df_no_out['price/sq.feet']/df_no_out['price/sq.feet'].max())
+ 0.07*(df_no_out['price/rooms']/df_no_out['price/rooms'].max())
+ 0.05*(df_no_out['mainroad'])
+ 0.05*(df_no_out['guestroom'])
+ 0.05*(df_no_out['hotwaterheating'])
+ 0.05*(df_no_out['airconditioning'])
+ 0.06*(df_no_out['prefarea'])
+ 0.05*(df_no_out['basement'])
+ 0.05*(df_no_out['stories'])
+ 0.05*(df_no_out['has_parking'])
+ 0.05*(df_no_out['furnishingstatus'].map({'furnished':1, 'semi-furnished':0.5, 'unfurnished':0}))

df_no_out['luxury_score'] /= df_no_out['luxury_score'].max()
df_no_out.head()

"""# Introducing a new parameter: luxury_category"""

ranges = [0, 0.25, 0.5, 0.75, 1.1]
category = ['poor', 'average', 'good', 'excellent']
df_no_out['luxury_category'] = pd.cut(df_no_out['luxury_score'], bins=ranges, labels=category, right=False)

"""# Checking the amount of outliners still remained despite IQR method"""

sns.boxplot(x='furnishingstatus', y='area', data=df_no_out)
plt.title('Boxplot for price vs area')
plt.show()

fig3 = px.box(df_no_out, x='furnishingstatus', y='area', title='Boxplot for price vs area', notched=True, points='all')
fig3.show()

"""# Plotting a KDE again to check effect after removing outliners"""

sns.kdeplot(x='area' , y='price', data=df_no_out, hue='furnishingstatus', fill=True, thresh=0.005)
plt.xlabel('Area')
plt.ylabel('Price')
plt.title('Price Distribution by Furnishing Status')
plt.show()

fig4 = px.density_contour(df_no_out, x='area', y='price', color='furnishingstatus', title='Price Distribution by Furnishing Status')
fig4.update_traces(contours_coloring="fill", contours_showlabels = True)
fig4.show()

"""It seems that both (boxplot, KDEplot) plots have not changed much as number of outliners removed are less (12) compared to original dataset (545), also it indicates that the data is not much skewed which might change the apperance of the graphs

# KDE Plot to show that outiners in this dataset were not much dominant
"""

print(f"% error = {outliners / len(df) * 100}")
sns.kdeplot(x='price', data=df_no_out, label='After IQR')
sns.kdeplot(x='price', data=df, label='Before IQR')
plt.xlabel('Price')
plt.ylabel('Density')
plt.title('KDE Plot of Price : Before vs After IQR Method')
plt.legend()
plt.show()

"""# A simple barplot to compare air conditioning w.r.t furnishing status"""

sns.barplot(x='airconditioning', data=df_no_out, hue='furnishingstatus')
plt.ylabel('Air Conditioning')
plt.xlabel('Count')
plt.title('Count of Air Conditioning by Furnishing Status')
plt.legend(loc='best')
plt.show()

"""# A Violin Plot to observe the distribution of data"""

sns.violinplot(x='airconditioning', y='log_area', data=df_no_out, label='log(area)')
sns.violinplot(x='airconditioning', y='log_prices', data=df_no_out, label='log(price)')
sns.violinplot(x='airconditioning', y='total_rooms', data=df_no_out, label='rooms')
plt.xlabel('Air Conditioning')
plt.title('Violin Plot to observe the distribution of data')
plt.ylabel('count')
plt.legend(loc='best')
plt.show()

fig5 = px.violin(df_no_out, x='airconditioning', y='log_area', title='Violin Plot to observe the distribution of data', box=True, points='all', color='furnishingstatus')
fig5.show()

"""# Scatter Plot of observe luxury score w.r.t area of House"""

sns.scatterplot(x='luxury_score', y='area', data=df_no_out)
plt.xlabel('Luxury Score')
plt.ylabel('Area')
plt.title('Scatter Plot of Luxury Score vs Area')
plt.show()

fig6 = px.scatter(df_no_out, x='luxury_score', y='area', title='Scatter Plot of Luxury Score vs Area', color='furnishingstatus', marginal_x='histogram', marginal_y='histogram')
fig6.show()

"""# Plotting a Histogram to compare the frequencies of categories in luxury"""

sns.histplot(x='luxury_category', data=df_no_out, hue='furnishingstatus', kde=True)
plt.xlabel('Luxury Category')
plt.ylabel('Count')
plt.title('Count of Luxury Category by Furnishing Status')
plt.show()

"""# Scatter PLot of Luxury Score vs Luxury Category w.r.t Furnishing Status"""

sns.scatterplot(y='luxury_score', x='luxury_category', data=df_no_out, hue='furnishingstatus')
plt.ylabel('Luxury Score')
plt.xlabel('Luxury Category')
plt.title('Scatter Plot of Luxury Score vs Luxury Category w.r.t Furnishing Status')
plt.legend(loc='best')
plt.show()

"""# Correlation Matrix"""

plt.figure(figsize=(11,11))
sns.heatmap(df_no_out.corr(numeric_only=True), cmap='coolwarm', linewidths=0.5, linecolor='black', annot=True)
plt.title('Correlation Matrix')
plt.tight_layout()
plt.show()

"""# Plotting a Pairplot to get relations between parameters"""

sns.pairplot(df_no_out, vars=['price', 'area', 'stories', 'parking', 'log_prices', 'log_area', 'luxury_score'], hue='furnishingstatus')
plt.show()

"""# ***Machine Learning Algorithms & code***

## Importing all libraries for making preditive model
"""

from sklearn.model_selection import train_test_split                            # splits dataset according to test_size
from sklearn.preprocessing import PolynomialFeatures                            # forms model with degree mentioned by us
from sklearn.linear_model import LinearRegression                               # gets a linear regression model
from sklearn.linear_model import ElasticNet                                     # does both lasso & ridge
from sklearn.metrics import r2_score                                            # calculates R squared
from sklearn.model_selection import cross_val_score, RepeatedKFold# calculated cross-validation score # does n_splits on dataset which are to be repeated m times another way of using KFold for smartly without doing too many folds

"""Listing features used in prediction in DataFrame"""

df1 = df_no_out.copy()
X = df1[['log_area', 'total_rooms', 'stories', 'has_parking', 'mainroad']]
y = df1['log_prices']

"""Feature Transforming & splitting dataset for testing"""

poly = PolynomialFeatures(degree=1, include_bias=False)
X_poly = poly.fit_transform(X)
ElasticNet(alpha=0.1)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model = LinearRegression()
model.fit(X_train, y_train)

"""Calculating R² for predition model"""

y_pred = model.predict(X_test)
print("R² Score:", r2_score(y_test, y_pred))

"""Carrying out Repeated K Fold to get average R², ensuring that its a stable model and not "lucky" or "unlucky" due to random_state selected earlier"""

rkf = RepeatedKFold(n_splits=10, n_repeats=10, random_state=42)
scores = cross_val_score(model, X, y, cv=RepeatedKFold(n_splits=10, n_repeats=10), scoring='r2')

print("Average R²:", np.mean(scores))

"""## Getting Exact Model Expression"""

feature_names = [f"x{i}" for i in range(X.shape[1])]
poly_feature_names = poly.get_feature_names_out(X.columns)

coefs = model.coef_
intercept = model.intercept_

terms = [f"{intercept:.4f}"]
for coef, name in zip(coefs, poly_feature_names):
    if name == "1":
        continue
    terms.append(f"{coef:.4f}*{name}")

expression = " + ".join(terms)
print("Model Expression:\n", expression)

area_values = np.linspace(500, 16000, 100)
log_area = np.log(area_values)

total_rooms = 8
stories = 7
has_parking = 1
mainroad = 1

log_price = (
    11.4929
    + 0.3587 * log_area
    + 0.1020 * total_rooms
    + 0.0940 * stories
    + 0.0685 * has_parking
    + 0.1474 * mainroad
)

price = np.exp(log_price)

plt.figure(figsize=(10, 6))
plt.plot(area_values, price, color='green', linewidth=2)
plt.title("Predicted House Price (Linear Model)")
plt.xlabel("Area (sqft)")
plt.ylabel("Predicted Price (INR)")
plt.grid(True)
plt.tight_layout()
plt.show()